{"visual":{"name":"PowerBI-visuals-forcasting-ARIMA","displayName":"Forecasting with ARIMA","guid":"PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML","visualClassName":"Visual","version":"1.0.1","description":"<span> Time series forecasting is the use of a model to predict future values based on previously observed values. Current visual implements well known Autoregressive Integrated Moving Average (ARIMA) method for the forecasting. Both seasonal and non-seasonal modeling is supported. You can control the algorithm parameters and the visual attributes to suit your needs.<br/><br/><span style='font-style:italic'>Service prerequisites:</span> R-powered custom visual is used in service seamlessly<br/><br /><span style='font-style:italic'>Desktop prerequisites:</span> To run R scripts in Power BI Desktop, you must separately install R on your local computer.<br />You can download and install R for free from the <a href='https://mran.revolutionanalytics.com/download/'>Revolution Open download page</a> or the <a href='https://cran.r-project.org/bin/windows/base/'>CRAN Repository</a><br /><br /> <span style='font-style:italic'> R package dependencies(auto-installed): </span> graphics, scales, forecast, zoo,  htmlWidgets, XML, plotly <br /><br /> <span style='font-style:italic'> Supports R versions: </span> R 3.3.1, R 3.3.0, MRO 3.3.1, MRO 3.3.0, MRO 3.2.2  <br /></span>","supportUrl":"http://community.powerbi.com/","gitHubUrl":"https://github.com/microsoft/PowerBI-visuals-forcastingarima"},"apiVersion":"1.4.0","author":{"name":"Microsoft","email":"pbicvsupport@microsoft.com"},"assets":{"icon":"assets/icon.png"},"externalJS":[],"style":"style/visual.less","capabilities":{"dataRoles":[{"displayName":"Date","description":"Equally spaced date values","kind":"Grouping","name":"Date"},{"displayName":"Value","description":"Numeric column","kind":"Measure","name":"Value"}],"dataViewMappings":[{"conditions":[{"Date":{"max":1},"Value":{"max":1}}],"scriptResult":{"dataInput":{"table":{"rows":{"select":[{"for":{"in":"Date"}},{"for":{"in":"Value"}}],"dataReductionAlgorithm":{"top":{}}}}},"script":{"scriptProviderDefault":"R","scriptOutputType":"html","source":{"objectName":"rcv_script","propertyName":"source"},"provider":{"objectName":"rcv_script","propertyName":"provider"},"scriptSourceDefault":"# Copyright (c) Microsoft Corporation.  All rights reserved.\r\n\r\n# Third Party Programs. This software enables you to obtain software applications from other sources. \r\n# Those applications are offered and distributed by third parties under their own license terms.\r\n# Microsoft is not developing, distributing or licensing those applications to you, but instead, \r\n# as a convenience, enables you to use this software to obtain those applications directly from \r\n# the application providers.\r\n# By using the software, you acknowledge and agree that you are obtaining the applications directly\r\n# from the third party providers and under separate license terms, and that it is your responsibility to locate, \r\n# understand and comply with those license terms.\r\n# Microsoft grants you no license rights for third-party software or applications that is obtained using this software.\r\n\r\n#\r\n# WARNINGS:   \r\n#\r\n# CREATION DATE: 24/7/2016\r\n#\r\n# LAST UPDATE: 18/01/2017\r\n#\r\n# VERSION: 1.0.0\r\n#\r\n# R VERSION TESTED: 3.3.1\r\n# \r\n# AUTHOR: pbicvsupport@microsoft.com\r\n#\r\n# REFERENCES: https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average, https://www.otexts.org/fpp/8\r\n\r\n############### Utility functions ###############\nlibraryRequireInstall = function(packageName, ...)\n{\n  if(!require(packageName, character.only = TRUE)) \n    warning(paste(\"*** The package: '\", packageName, \"' was not installed ***\", sep=\"\"))\n}\n\nlibraryRequireInstall(\"XML\")\nlibraryRequireInstall(\"htmlwidgets\")\n\ninternalSaveWidget <- function(widget, fname)\n{\n  tempFname = paste(fname, \".tmp\", sep=\"\")\n  htmlwidgets::saveWidget(widget, file = tempFname, selfcontained = FALSE)\n  FlattenHTML(tempFname, fname)\n}\n\nFlattenHTML <- function(fnameIn, fnameOut)\n{\n  # Read and parse HTML file\n  # Embed all js and css files into one unified file\n  \n  if(!file.exists(fnameIn))\n    return(FALSE)\n  \n  dir = dirname(fnameIn)\n  html = htmlTreeParse(fnameIn, useInternal = TRUE)\n  top = xmlRoot(html)\n  \n  # extract all <script> tags with src value\n  srcNode=getNodeSet(top, '//script[@src]')\n  for (node in srcNode)\n  {\n    b = xmlAttrs(node)\n    fname = file.path(dir, b['src'])\n    alternateSrc = FindSrcReplacement(fname)\n    if (!is.null(alternateSrc))\n    {\n      s = alternateSrc\n      names(s) = 'src'\n      newNode = xmlNode(\"script\",attrs = s)\n      replaceNodes(node, newNode)\n    }else{\n      str=ReadFileForEmbedding(fname);\n      if (!is.null(str))\n      {      \n        newNode = xmlNode(\"script\", str, attrs = c(type = \"text/javascript\"))\n        replaceNodes(node, newNode)\n      }\n    }\n  }\n  \n  # extract all <link> tags with src value\n  linkNode=getNodeSet(top, '//link[@href]')\n  for (node in linkNode)\n  {\n    b = xmlAttrs(node)\n    fname = file.path(dir, b['href'])\n    str = ReadFileForEmbedding(fname, FALSE);\n    if (!is.null(str))\n    {\n      newNode = xmlNode(\"style\", str)\n      replaceNodes(node, newNode)\n    }\n  }\n  \n  saveXML(html, file = fnameOut)\n  return(TRUE)\n}\n\nReadFileForEmbedding <- function(fname, addCdata = TRUE)\n{\n  data = ReadFullFile(fname)\n  if (is.null(data))\n    return(NULL)\n\n  str = paste(data, collapse ='\\n')\n  if (addCdata) {\n    str = paste(cbind('// <![CDATA[', str,'// ]]>'), collapse ='\\n')\n  }\n  return(str)\n}\n\nReadFullFile <- function(fname)\n{\n  if(!file.exists(fname))\n    return(NULL)\n  \n  con = file(fname, open = \"r\")\n  data = readLines(con)\n  close(con)\n  return(data)\n}\n\nFindSrcReplacement <- function(str)\n{\n  # finds reference to 'plotly' js and replaces with a version from CDN\n  # This allows the HTML to be smaller, since this script is not fully embedded in it\n  str <- iconv(str, to=\"UTF-8\")\n  pattern = \"plotlyjs-(\\\\w.+)/plotly-latest.min.js\"\n  match1=regexpr(pattern, str)\n  attr(match1, 'useBytes') <- FALSE\n  strMatch=regmatches(str, match1, invert = FALSE)\n  if (length(strMatch) == 0) return(NULL)\n  \n  pattern2 = \"-(\\\\d.+)/\"\n  match2 = regexpr(pattern2, strMatch[1])\n  attr(match2, 'useBytes') <- FALSE\n  strmatch = regmatches(strMatch[1], match2)\n  if (length(strmatch) == 0) return(NULL)\n  \n  # CDN url is https://cdn.plot.ly/plotly-<Version>.js\n  # This matches the specific version used in the plotly package used.\n  verstr = substr(strmatch, 2, nchar(strmatch)-1)\n  str = paste('https://cdn.plot.ly/plotly-', verstr,'.min.js', sep='')\n  return(str)\n}\n#################################################\n\n\r\n\r\n############### Library Declarations ###############\r\nlibraryRequireInstall(\"ggplot2\");\r\nlibraryRequireInstall(\"plotly\")\r\n####################################################\r\n\r\n#DEBUG \r\nfileRda = \"C:/Users/boefraty/projects/PBI/R/tempData.Rda\"\r\nif(file.exists(dirname(fileRda)))\r\n{\r\n  if(Sys.getenv(\"RSTUDIO\")!=\"\")\r\n    load(file= fileRda)\r\n  else\r\n    save(list = ls(all.names = TRUE), file=fileRda)\r\n}\r\n\r\n\r\n\r\nSys.setlocale(\"LC_ALL\",\"English\") # internationalization\r\n\r\n\r\n############ User Parameters #########\r\n\r\n\r\n\r\n##PBI_PARAM: Should additional info about the forcasting method be displayed?\r\n#Type:logical, Default:TRUE, Range:NA, PossibleValues:NA, Remarks: NA\r\nshowInfo=TRUE\r\nif(exists(\"settings_additional_params_show\"))\r\n  showInfo = settings_additional_params_show\r\n\r\n##PBI_PARAM: Output information criteria\r\n#Type:enum, Default:\"none\", Range:NA, PossibleValues:none, AIC,BIC,AICc, Remarks: NA\r\ninfoCriteria = \"none\"\r\nif(exists(\"settings_additional_params_infoCriteria\"))\r\n  infoCriteria = settings_additional_params_infoCriteria\r\n\r\n##PBI_PARAM: Forecast length\r\n#Type:integer, Default:NULL, Range:NA, PossibleValues:NA, Remarks: NULL means choose forecast length automatically\r\nforecastLength=10\r\nif(exists(\"settings_forecastPlot_params_forecastLength\"))\r\n{\r\n  forecastLength = as.numeric(settings_forecastPlot_params_forecastLength)\r\n  if(is.na(forecastLength))\r\n    forecastLength = 10\r\n  forecastLength = round(max(min(forecastLength,1e+6),1))\r\n}\r\n\r\n##PBI_PARAM: Confidence level\r\n#Type:enum, Default:\"0.85\", Range:NA, PossibleValues:0, 0.5 etc, Remarks: NA\r\nconfInterval1 = 0.85\r\nif(exists(\"settings_forecastPlot_params_confInterval1\"))\r\n{\r\n  confInterval1 = as.numeric(settings_forecastPlot_params_confInterval1)\r\n}\r\n\r\n\r\n##PBI_PARAM: Confidence level\r\n#Type:enum, Default:\"0.95\", Range:NA, PossibleValues:0, 0.5 etc, Remarks: NA\r\nconfInterval2 = 0.95\r\nif(exists(\"settings_forecastPlot_params_confInterval2\"))\r\n{\r\n  confInterval2 = as.numeric(settings_forecastPlot_params_confInterval2)\r\n}\r\n\r\n\r\n##PBI_PARAM: Does the model assume seasonality? \r\n#Type:logical, Default:TRUE, Range:NA, PossibleValues:NA, Remarks: NA\r\nwithSeasonality = TRUE \r\nif(exists(\"settings_seasonality_params_show\"))\r\n  withSeasonality = settings_seasonality_params_show\r\n\r\n\r\n##PBI_PARAM target Season\r\n#Type: string, Default:\"automatic\", Range:NA, PossibleValues:\"automatic\",\"hour\",\"day\",\"week\", ...\r\ntargetSeason = \"automatic\"\r\nif(exists(\"settings_seasonality_params_targetSeason\"))\r\n  targetSeason = settings_seasonality_params_targetSeason\r\n\r\n##PBI_PARAM target frequency (samples per period)\r\n#Type: numeric, Default:12 , Range:[2,10^6], PossibleValues:NA\r\nknownFrequency = 12\r\nif(exists(\"settings_seasonality_params_knownFrequency\")) \r\n  knownFrequency = min(1000000,max(2,settings_seasonality_params_knownFrequency))\r\n\r\n\r\n##PBI_PARAM The maximal order of the  autoregressive component\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nmaxp  = 3\r\nif(exists(\"settings_model_params_maxp\")) \r\n  maxp = as.numeric(settings_model_params_maxp)\r\n\r\n##PBI_PARAM The maximal order of the  moving average component\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nmaxq  = 3\r\nif(exists(\"settings_model_params_maxq\")) \r\n  maxq = as.numeric(settings_model_params_maxq)\r\n\r\n##PBI_PARAM The maximal degree of the differentiation\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\"\r\nmaxd  = 2\r\nif(exists(\"settings_model_params_maxd\")) \r\n  maxd = as.numeric(settings_model_params_maxd)\r\n\r\n##PBI_PARAM The maximal order of the seasonal autoregressive component\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nmaxP  = 2 \r\nif(exists(\"settings_model_params_maxP\")) \r\n  maxP = as.numeric(settings_model_params_maxP)\r\n\r\n##PBI_PARAM The maximal order of the seasonal moving average component\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nmaxQ  = 2\r\nif(exists(\"settings_model_params_maxQ\")) \r\n  maxQ = as.numeric(settings_model_params_maxQ)\r\n\r\n##PBI_PARAM The maximal degree of the seasonal differentiation\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\"\r\nmaxD  = 1\r\nif(exists(\"settings_model_params_maxD\")) \r\n  maxD = as.numeric(settings_model_params_maxD)\r\n\r\n##PBI_PARAM: Should the ARIMA model include a linear drift term?\r\n#Type:logical, Default:FALSE, Range:NA, PossibleValues:NA, Remarks: NA\r\nallowDrift  = TRUE\r\nif(exists(\"settings_model_params_allowDrift\")) \r\n  allowDrift = (settings_model_params_allowDrift)\r\n\r\n##PBI_PARAM: Should the ARIMA model include a mean term?\r\n#Type:logical, Default:FALSE, Range:NA, PossibleValues:NA, Remarks: NA\r\nallowMean  = FALSE\r\nif(exists(\"settings_model_params_allowMean\")) \r\n  allowMean = settings_model_params_allowMean\r\n\r\n##PBI_PARAM: If TRUE, will do stepwise selection (faster). Otherwise, it searches over all models (can be very slow).\r\n#Type:logical, Default:TRUE, Range:NA, PossibleValues:NA, Remarks: NA\r\nstepwiseSelection  = TRUE\r\nif(exists(\"settings_model_params_stepwiseSelection\")) \r\n  stepwiseSelection = settings_model_params_stepwiseSelection\r\n\r\n##PBI_PARAM Box-Cox transformation\r\n#Type: enum/string, Default:\"off\", Range:NA, PossibleValues:\"off\",\"manual\",\"automatic\"\r\nboxCoxTransform = \"off\"\r\nif(exists(\"settings_model_params_boxCoxTransform\")) \r\n  boxCoxTransform = settings_model_params_boxCoxTransform\r\n\r\n##PBI_PARAM Box-Cox transformation parameter\r\n#Type: numeric, Default:0, Range:[-1,2], PossibleValues:NA\r\nlambda  = 0\r\nif(exists(\"settings_model_params_lambda\")) \r\n  lambda = max(-0.5,min(settings_model_params_lambda,1.5))\r\n\r\n##PBI_PARAM: User model? \r\n#Type:logical, Default:TRUE, Range:NA, PossibleValues:NA, Remarks: NA\r\nuserModel  = FALSE\r\nif(exists(\"settings_userModel_params_show\")) \r\n  userModel = settings_userModel_params_show\r\n\r\n##PBI_PARAM The order of the autoregressive component\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\np  = 1\r\nif(exists(\"settings_userModel_params_p\")) \r\n  p = as.numeric(settings_userModel_params_p)\r\n\r\n##PBI_PARAM The maximal order of the moving average component\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nq  = 1\r\nif(exists(\"settings_userModel_params_q\")) \r\n  q = as.numeric(settings_userModel_params_q)\r\n\r\n##PBI_PARAM The degree of the differencing\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nd  = 1\r\nif(exists(\"settings_userModel_params_d\")) \r\n  d = as.numeric(settings_userModel_params_d)\r\n\r\n##PBI_PARAM The  order of the seasonal autoregressive component\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nP  = 1\r\nif(exists(\"settings_userModel_params_P\")) \r\n  P = as.numeric(settings_userModel_params_P)\r\n\r\n##PBI_PARAM The maximal order of the seasonal moving average component\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nQ  = 1\r\nif(exists(\"settings_userModel_params_Q\")) \r\n  Q = as.numeric(settings_userModel_params_Q)\r\n\r\n##PBI_PARAM The degree of the differencing\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nD  = 0\r\nif(exists(\"settings_userModel_params_D\")) \r\n  D = as.numeric(settings_userModel_params_D)\r\n\r\n##PBI_PARAM Color of time series line\r\n#Type:string, Default:\"orange\", Range:NA, PossibleValues:\"orange\",\"blue\",\"green\",\"black\"\r\npointsCol = \"blue\"\r\nif(exists(\"settings_graph_params_dataCol\"))\r\n  pointsCol = settings_graph_params_dataCol\r\n\r\n##PBI_PARAM Color of forecast line\r\n#Type:string, Default:\"red\", Range:NA, PossibleValues:\"red\",\"blue\",\"green\",\"black\"\r\nforecastCol = \"orange\"\r\nif(exists(\"settings_graph_params_forecastCol\"))\r\n  forecastCol = settings_graph_params_forecastCol\r\n\r\n#PBI_PARAM Transparency of scatterplot points\r\n#Type:numeric, Default:0.4, Range:[0,1], PossibleValues:NA, Remarks: NA\r\ntransparency = 1\r\nif(exists(\"settings_graph_params_percentile\"))\r\n  transparency = as.numeric(settings_graph_params_percentile)/100\r\n\r\n\r\n###############Library Declarations###############\r\n\r\nlibraryRequireInstall = function(packageName, ...)\r\n{\r\n  if(!require(packageName, character.only = TRUE)) \r\n    warning(paste(\"*** The package: '\", packageName, \"' was not installed ***\",sep=\"\"))\r\n}\r\n\r\n\r\nlibraryRequireInstall(\"scales\")\r\nlibraryRequireInstall(\"forecast\")\r\nlibraryRequireInstall(\"zoo\")\r\n\r\n###############Internal parameters definitions#################\r\n##PBI_PARAM: Should warnings text be displayed?\r\n#Type:logical, Default:TRUE, Range:NA, PossibleValues:NA, Remarks: NA\r\nshowWarnings = FALSE\r\n\r\n\r\n#PBI_PARAM Minimal number of points\r\n#Type:integer, Default:10, Range:[0,], PossibleValues:NA, Remarks: NA\r\nminPoints = 10\r\n\r\n\r\n#PBI_PARAM Shaded band for confidence interval\r\n#Type:logical, Default:TRUE, Range:NA, PossibleValues:NA, Remarks: NA\r\nfillConfidenceLevels=TRUE\r\n\r\n#PBI_PARAM Size of points on the plot\r\n#Type:numeric, Default: 1 , Range:[0.1,5], PossibleValues:NA, Remarks: NA\r\npointCex = 1\r\nif(exists(\"settings_graph_params_weight\"))\r\n  pointCex = as.numeric(settings_graph_params_weight)/10\r\n\r\n#PBI_PARAM Size of subtitle on the plot\r\n#Type:numeric, Default: 0.75 , Range:[0.1,5], PossibleValues:NA, Remarks: NA\r\ncexSub = 1\r\nif(exists(\"settings_additional_params_textSize\"))\r\n  cexSub = as.numeric(settings_additional_params_textSize)/12\r\n\r\n\r\ninfoTextColor = \"brown\"\r\nif(exists(\"settings_additional_params_textColor\"))\r\n  infoTextColor = settings_additional_params_textColor\r\n\r\nif(confInterval1 > confInterval2)\r\n{#switch places\r\n  temp = confInterval1\r\n  confInterval1 = confInterval2\r\n  confInterval2 = temp\r\n}\r\n\r\nlowerConfInterval = confInterval1\r\nupperConfInterval = confInterval2\r\n\r\n\r\n#PBI_PARAM Size of labels on axes\r\n#Type:numeric , Default:12, Range:NA, PossibleValues:[1,50], Remarks: NA\r\nsizeLabel = 12\r\n\r\n#PBI_PARAM Size of warnings font\r\n#Type:numeric , Default:cexSub*12, Range:NA, PossibleValues:[1,50], Remarks: NA\r\nsizeWarn = cexSub*12\r\n\r\n#PBI_PARAM Size of ticks on axes \r\nsizeTicks = 8\r\n\r\n#PBI_PARAM opacity of conf interval color\r\ntransparencyConfInterval = 0.3 \r\n\r\n\r\n###############Internal functions definitions#################\r\n\r\n# tiny function to deal with verl long strings on plot\r\ncutStr2Show = function(strText, strCex = 0.8, abbrTo = 100, isH = TRUE, maxChar = 3, partAvailable = 1)\r\n{\r\n  # partAvailable, wich portion of window is available, in [0,1]\r\n  if(is.null(strText))\r\n    return (NULL)\r\n  \r\n  SCL = 0.075*strCex/0.8\r\n  pardin = par()$din\r\n  gStand = partAvailable*(isH*pardin[1]+(1-isH)*pardin[2]) /SCL\r\n  \r\n  # if very very long abbreviate\r\n  if(nchar(strText)>abbrTo && nchar(strText)> 1)\r\n    strText = abbreviate(strText, abbrTo)\r\n  \r\n  # if looooooong convert to lo...\r\n  if(nchar(strText)>round(gStand) && nchar(strText)> 1)\r\n    strText = paste(substring(strText,1,floor(gStand)),\"...\",sep=\"\")\r\n  \r\n  # if shorter than maxChar remove \r\n  if(gStand<=maxChar)\r\n    strText = NULL\r\n  \r\n  return(strText) \r\n}\r\n\r\n\r\n# Find number of ticks on X axis \r\nFindTicksNum = function(n,f)\r\n{\r\n  tn = 10 # default minimum\r\n  D = 2 # tick/inch\r\n  numCircles = n/f\r\n  xSize = par()$din[1]\r\n  tn = max(round(xSize*D),tn)\r\n  return(tn) \r\n}\r\n\r\n#format labels on X-axis automatically \r\nflexFormat = function(dates, orig_dates, freq = 1, myformat = NULL)\r\n{\r\n  \r\n  days=(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"days\"))\r\n  months = days/30\r\n  years = days/365.25\r\n  \r\n  \r\n  constHour = length(unique(orig_dates$hour))==1\r\n  constMin = length(unique(orig_dates$min))==1\r\n  constSec = length(unique(orig_dates$sec))==1\r\n  constMon = length(unique(orig_dates$mon))==1\r\n  \r\n  timeChange = any(!constHour,!constMin,!constSec)\r\n  \r\n  if(is.null(myformat))\r\n  {\r\n    if(years > 10){\r\n      if(constMon)\r\n      {\r\n        myformat = \"%Y\" #many years => only year :2001\r\n      }else{\r\n        myformat = \"%m/%y\" #many years + months :12/01\r\n      }\r\n    }else{\r\n      if(years > 1 && N < 50){\r\n        myformat = \"%b %d, %Y\" #several years, few samples:Jan 01, 2010\r\n      }else{\r\n        if(years > 1){\r\n          myformat = \"%m/%d/%y\" #several years, many samples: 01/20/10\r\n        }else{\r\n          if(years <= 1 && !timeChange)\r\n            myformat = \"%b %d\" #1 year,no time: Jan 01\r\n        }  \r\n      }\r\n    }\r\n  }\r\n  if(is.null(myformat) && timeChange)\r\n    if(years>1){\r\n      myformat = \"%m/%d/%y %H:%M\" # 01/20/10 12:00\r\n    }else{\r\n      if(days>1){\r\n        myformat = \"%b %d, %H:%M\" # Jan 01 12:00\r\n      }else{\r\n        if(days<=1){\r\n          myformat = \"%H:%M\" # Jan 01 12:00\r\n        }  \r\n      }\r\n    }\r\n  if(!is.null(myformat)){\r\n    if(myformat == \"%Y,Q%q\")\r\n      dates = as.yearqtr(dates)\r\n    dates1= format(dates,  myformat)\r\n  }else{\r\n    dates1 = as.character(1:length(dates)) # just id \r\n  }\r\n  return(dates1)\r\n}\r\n\r\n\r\n# verify if \"perSeason\" is good for \"frequency\" parameter\r\nfreqSeason1 = function(seasons,perSeason)\r\n{\r\n  if((seasons > 5 && perSeason > 3) || (seasons > 2 && perSeason > 7))\r\n    return (perSeason)\r\n  \r\n  return(1)\r\n}\r\n\r\n\r\n# find frequency using the dates, targetS is a \"recommended\" seasonality \r\nfindFreqFromDates1 = function(dates, targetS = \"Automatic\")\r\n{\r\n  freq = 1\r\n  N = length(dates)\r\n  nnn = c(\"hour\", \"day\", \"week\", \"month\", \"quater\", \"year\")\r\n  seasons = rep(NaN,6)\r\n  names(seasons) = nnn\r\n  perSeason = seasons\r\n  \r\n  seasons[\"day\"]=round(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"days\"))\r\n  seasons[\"hour\"]=round(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"hours\"))\r\n  seasons[\"week\"]=round(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"weeks\"))\r\n  seasons[\"month\"] = seasons[\"day\"]/30\r\n  seasons[\"year\"] = seasons[\"day\"]/365.25\r\n  seasons[\"quater\"] = seasons[\"year\"]*4\r\n  \r\n  perSeason = N/seasons\r\n  \r\n  if(targetS!=\"automatic\") # target \r\n    freq = perSeason[targetS]\r\n  \r\n  if(freq < 2) # if TRUE, target season factor is not good \r\n    freq = 1\r\n  \r\n  for( s in rev(nnn)) # check year --> Quater --> etc\r\n    if(freq == 1 )\r\n      freq = freqSeason1(seasons[s],perSeason[s])\r\n  \r\n  return(round(freq))\r\n}\r\n\r\n#get valid frequency parameter, based on input from user \r\ngetFrequency1 = function(parsed_dates, values, tS, f)\r\n{\r\n  myFreq = f\r\n  grp = c(\"automatic\",\"none\",\"manual\")\r\n  \r\n  if(!(tS %in% c(\"autodetect from value\",\"none\",\"manual\"))) #detect from date\r\n  {  \r\n    myFreq = findFreqFromDates1(parsed_dates, targetS = tS)\r\n  }else{\r\n    if(tS == \"none\")\r\n    { myFreq = 1}\r\n    else\r\n    {# NOT YET IMPLEMENTED\r\n      # if(tS == \"autodetect from value\")\r\n      #   myFreq = freqFromValue1(values)\r\n    }\r\n  }\r\n  numPeriods = floor(length(values)/myFreq)\r\n  if(numPeriods< 2)\r\n    myFreq = findFreqFromDates1(parsed_dates, targetS = \"automatic\")\r\n  return(myFreq)\r\n}\r\n\r\n#format info string \r\nGetFitMethodString = function(fit,withSeasonality, infoCriteria = \"none\")\r\n{\r\n  \r\n  arma = fit$arma\r\n  \r\n  resString = as.character(arimaorder(fit))\r\n  \r\n  skey = c(\"p\",\"d\",\"q\",\"P\",\"D\",\"Q\", \"m\")\r\n  skey = skey[1:length(resString)]\r\n  skey = paste(skey, collapse = \",\")\r\n  \r\n  resString = paste(\"ARIMA: (\",skey,\") = (\",paste(resString,collapse = \",\"),\")\",sep =\"\")\r\n  # add more info \r\n  if(infoCriteria != \"none\")\r\n  {\r\n    if(infoCriteria == \"AIC\")\r\n      resString = paste(resString, \"; AIC = \", as.character(round(fit$aic,2)), sep =\"\")\r\n    else\r\n      if(infoCriteria == \"AICc\")\r\n        resString = paste(resString, \"; AICc = \", as.character(round(fit$aicc,2)), sep =\"\")\r\n      else\r\n        if(infoCriteria == \"BIC\")\r\n          resString = paste(resString, \"; BIC = \", as.character(round(fit$bic,2)), sep =\"\")\r\n  }\r\n  \r\n  return(resString)\r\n  \r\n}\r\n\r\n# find lambda for Box-Cox transform\r\nFindBoxCoxLambda = function(timeSeries, boxCoxTransform, lambda = NULL,  mymethod = \"loglik\")\r\n{\r\n  if(boxCoxTransform == \"off\")\r\n    return(NULL)\r\n  if(boxCoxTransform == \"manual\")\r\n    return(lambda)\r\n  if(boxCoxTransform == \"automatic\")\r\n    lambda=BoxCox.lambda(timeSeries, method = mymethod, lower = -1, upper = 2)\r\n  return (lambda)\r\n}\r\n\r\n\r\ngetAngleXlabels = function(mylabels)\r\n{\r\n  NL = length(mylabels)\r\n  NC = nchar(mylabels[1])*1.1\r\n  \r\n  lenPerTick = par()$din[1]/(NL*NC)\r\n  \r\n  #lot of space -> 0 \r\n  if(lenPerTick > 0.15)\r\n    return(0)\r\n  \r\n  # no space --> -90\r\n  if(lenPerTick < 0.070)\r\n    return(90)\r\n  \r\n  # few space --> - 45\r\n  return(45)\r\n  \r\n}\r\n\r\n\r\n###############Upfront input correctness validations (where possible)#################\r\npbiWarning = NULL\r\n\r\nif(!exists(\"Date\") || !exists(\"Value\"))\r\n{\r\n  dataset=data.frame()\r\n  pbiWarning  = cutStr2Show(\"Both 'Date' and 'Value' fields are required.\", strCex = 1.1, partAvailable = 0.95)\r\n  timeSeries=ts()\r\n  showWarnings=TRUE\r\n}else{\r\n  dataset= cbind(Date,Value)\r\n  dataset<-dataset[complete.cases(dataset),] #remove corrupted rows\r\n  \r\n  labTime = \"Time\"\r\n  labValue=names(dataset)[ncol(dataset)]\r\n  \r\n  N=nrow(dataset)\r\n  \r\n  \r\n  if(N==0 && exists(\"Date\") && nrow(Date)>0 &&  exists(\"Value\")){\r\n    pbiWarning1  = cutStr2Show(\"Wrong date type. Only 'Date', 'Time', 'Date/Time' are allowed without hierarchy\", strCex = 1.1, partAvailable = 0.95)\r\n    pbiWarning = paste(pbiWarning1, pbiWarning, sep =\"\\n\")\r\n    timeSeries=ts()\r\n    showWarnings=TRUE\r\n  }else {\r\n    \r\n    \r\n    dataset = dataset[order(dataset[,1]),]\r\n    parsed_dates=strptime(dataset[,1],\"%Y-%m-%dT%H:%M:%S\",tz=\"UTC\")\r\n    labTime = names(Date)[1]\r\n    \r\n    if((any(is.na(parsed_dates))))\r\n    {\r\n      pbiWarning1  = cutStr2Show(\"Wrong or corrupted 'Date'.\", strCex = 1.1, partAvailable = 0.95)\r\n      pbiWarning2  = cutStr2Show(\"Only 'Date', 'Time', 'Date/Time' types are allowed without hierarchy\", strCex = 1.1, partAvailable = 0.95)\r\n      pbiWarning = paste(pbiWarning1, pbiWarning2, pbiWarning, sep =\"\\n\")\r\n      timeSeries=ts()\r\n      showWarnings=TRUE\r\n    }\r\n    else\r\n    {\r\n      interval = difftime(parsed_dates[length(parsed_dates)],parsed_dates[1])/(length(parsed_dates)-1) # force equal spacing \r\n      \r\n      if(withSeasonality==FALSE)\r\n        targetSeason = \"none\"\r\n      \r\n      myFreq = getFrequency1(parsed_dates, values = dataset[,2], tS = targetSeason, f = knownFrequency)\r\n      \r\n   \r\n      if(myFreq < 2)\r\n        withSeasonality = FALSE\r\n      \r\n      if(withSeasonality == FALSE)\r\n      {\r\n        maxP = maxQ = maxD = P = Q = D = 0 \r\n      }\r\n      \r\n      \r\n      timeSeries=ts(data = dataset[,2], start=1, frequency = round(myFreq))\r\n    }\r\n    \r\n    \r\n  }\r\n}\r\n\r\n##############Main Visualization script###########\r\n\r\npbiInfo = NULL\r\n\r\nif(length(timeSeries)>=minPoints) {\r\n  \r\n  lambda = FindBoxCoxLambda(timeSeries, boxCoxTransform, lambda)\r\n  \r\n  fit = NULL\r\n  #if user model fails do auto.arima\r\n  if(userModel)\r\n  {\r\n    result <- tryCatch({\r\n      fit = suppressWarnings(Arima(timeSeries, order = c(p,d,q), seasonal = c(P,D,Q), \r\n                                   include.mean=allowMean, include.drift=allowDrift, \r\n                                   method = \"ML\", lambda=lambda))\r\n    }, warning = function(war) {\r\n      \r\n      # warning handler picks up where error was generated\r\n      print(paste(\"MY_WARNING:  \",war))\r\n      return(\"Arima_warning\")\r\n      \r\n    }, error = function(err) {\r\n      \r\n      # error handler picks up where error was generated\r\n      print(paste(\"MY_ERROR: \",err))\r\n      return(\"Arima_error\")\r\n      \r\n    }, finally = {\r\n      \r\n    }) # END tryCatch\r\n    \r\n  }\r\n  \r\n  if(is.null(fit))\r\n    fit = auto.arima(timeSeries, max.p = maxp, max.q = maxq, max.d = maxd, \r\n                     max.P = maxP, max.Q = maxQ, max.D = maxD,\r\n                     seasonal= withSeasonality,allowdrift=allowDrift, allowmean=allowMean, lambda=lambda,\r\n                     max.order=4, parallel = FALSE, stepwise = stepwiseSelection)\r\n  \r\n  \r\n  \r\n  fit$method = GetFitMethodString(fit,withSeasonality, infoCriteria)\r\n  if(lowerConfInterval==0)\r\n    lowerConfInterval = NULL; \r\n  prediction = forecast(fit, level=c(lowerConfInterval,upperConfInterval), h=forecastLength)\r\n  \r\n  lastValue = tail(prediction$x,1)\r\n  \r\n  prediction$mean=ts(c(lastValue,prediction$mean), \r\n                     frequency = frequency(prediction$mean), \r\n                     end=end(prediction$mean))\r\n  # \r\n  prediction$upper=rbind(c(lastValue,lastValue),prediction$upper)\r\n  #\r\n  prediction$lower=rbind(c(lastValue,lastValue),prediction$lower)\r\n  \r\n  if(showInfo)\r\n  {\r\n    pbiInfo=paste(pbiInfo,\"\", fit$method, sep=\"\")\r\n    pbiInfo = cutStr2Show(pbiInfo,strCex = cexSub, isH = TRUE, maxChar = 20)\r\n  }\r\n  \r\n  labTime = cutStr2Show(labTime, strCex =1.1, isH = TRUE)\r\n  labValue = cutStr2Show(labValue, strCex =1.1, isH = FALSE)\r\n  \r\n  # plot.forecast(prediction, lwd=pointCex, col=alpha(pointsCol,transparency), fcol=alpha(forecastCol,transparency), flwd = pointCex, shaded=fillConfidenceLevels,\r\n  #               main = \"\", sub = pbiInfo, col.sub = infoTextColor, cex.sub = cexSub, xlab = labTime, ylab = labValue, xaxt = \"n\")\r\n  \r\n \r\n  \r\n  \r\n  \r\n  NpF = (length(parsed_dates))+forecastLength\r\n  freq = frequency(timeSeries)\r\n  \r\n  #format  x_with_f\r\n  numTicks = FindTicksNum(NpF,freq) # find based on plot size\r\n  \r\n  x_with_f = as.POSIXlt(seq(from=parsed_dates[1], to = (parsed_dates[1]+interval*(length(parsed_dates)+forecastLength)), length.out = numTicks))\r\n  x_with_forcast_formatted = flexFormat(dates = x_with_f, orig_dates = parsed_dates, freq = freq)\r\n  \r\n  \r\n  x_full = as.POSIXlt(seq(from=parsed_dates[1], to = tail(parsed_dates,1), length.out = length(parsed_dates)))\r\n  f_full = as.POSIXlt(seq(from=tail(parsed_dates,1), to = (tail(parsed_dates,1)+interval*(forecastLength)), length.out = forecastLength+1))\r\n  \r\n  \r\n  \r\n  correction = (NpF-1)/(numTicks-1) # needed due to subsampling of ticks\r\n  #axis(1, at = 1+correction*((0:(numTicks-1))/freq), labels = x_with_forcast_formatted)\r\n  \r\n  \r\n  \r\n  if(!showWarnings)\r\n  {\r\n    \r\n    #HTML\r\n    #historical data\r\n    x1 = seq(1,length(prediction$x))\r\n    y1 = as.numeric(prediction$x)\r\n    \r\n    p1a<-ggplot(data=NULL,aes(x=x1,y=y1) )\r\n    p1a<-p1a+geom_line(col=alpha(pointsCol,transparency), lwd = pointCex)\r\n    \r\n    #forecast\r\n    x2 = seq(length(prediction$x),length.out = length(prediction$mean))\r\n    y2 = as.numeric(prediction$mean)\r\n    \r\n    \r\n    p1a <- p1a + geom_line(inherit.aes = FALSE ,data = NULL, mapping = aes(x = x2, y = y2), col=alpha(forecastCol,transparency), lwd = pointCex)\r\n    \r\n    #conf intervals\r\n    if(upperConfInterval>0.01)\r\n    {\r\n      lower1 = as.numeric(prediction$lower[,1])\r\n      upper1 = as.numeric(prediction$upper[,1])\r\n      lower2 = as.numeric(prediction$lower[,2])\r\n      upper2 = as.numeric(prediction$upper[,2])\r\n      id = x2\r\n      \r\n      names(lower1) = names(lower2) = names(upper1)= names(upper2) = names(f_full) = id   \r\n      cf_full = as.character(f_full)\r\n      \r\n      p1a <- p1a + geom_ribbon( inherit.aes = FALSE , mapping = aes(x = id, ymin = lower1 , ymax = upper1), fill = \"blue4\", alpha = 0.25)\r\n      p1a <- p1a + geom_ribbon( inherit.aes = FALSE , mapping = aes(x = id, ymin = lower2, ymax = upper2), fill = \"gray50\", alpha = 0.25)\r\n      \r\n    }\r\n    \r\n    #design \r\n    p1a <- p1a + labs (title = pbiInfo, caption = NULL) + theme_bw() \r\n    p1a <- p1a + xlab(labTime) + ylab(labValue) \r\n    p1a <- p1a + scale_x_continuous(breaks = seq(1,length(prediction$x) + length(prediction$mean)-1, length.out = numTicks), labels = x_with_forcast_formatted) \r\n    p1a <- p1a +  theme(axis.text.x  = element_text(angle = getAngleXlabels(x_with_forcast_formatted), \r\n                                                    hjust=1, size = sizeTicks, colour = \"gray60\"),\r\n                        axis.text.y  = element_text(vjust = 0.5, size = sizeTicks, colour = \"gray60\"),\r\n                        plot.title  = element_text(hjust = 0.5, size = sizeWarn), \r\n                        axis.title=element_text(size =  sizeLabel),\r\n                        axis.text=element_text(size =  sizeTicks),\r\n                        panel.border = element_blank())\r\n    \r\n    \r\n    \r\n  }\r\n  \r\n  \r\n  \r\n} else{ #empty plot\r\n  # plot.new()\r\n  # showWarnings = TRUE\r\n  # pbiWarning1 = cutStr2Show(\"Not enough data points\", strCex = 1.1, partAvailable = 0.95)\r\n  # pbiWarning<-paste(pbiWarning, pbiWarning1 , sep=\"\\n\")\r\n  \r\n  showWarnings = TRUE\r\n  pbiWarning1  = cutStr2Show(\"Not enough data points\", strCex = sizeWarn/6, partAvailable = 0.85)\r\n  pbiWarning<-paste(pbiWarning, pbiWarning1 , sep=\"<br>\")\r\n  \r\n  \r\n}\r\n\r\n#add warning as subtitle\r\n# if(showWarnings)\r\n#   title(main=NULL, sub=pbiWarning, outer=FALSE, col.sub = infoTextColor, cex.sub=1.1)\r\n\r\n\r\n#add warning as subtitle\r\nif(showWarnings && !is.null(pbiWarning))\r\n{\r\n  p1a = ggplot() + labs (title = pbiWarning, caption = NULL) + theme_bw() +\r\n    theme(plot.title  = element_text(hjust = 0.5, size = sizeWarn), \r\n          axis.title=element_text(size =  sizeLabel),\r\n          axis.text=element_text(size =  sizeTicks),\r\n          panel.border = element_blank())\r\n  ggp <- plotly_build(p1a)\r\n}else{\r\n  \r\n  # massage some plot atributes to make transition from ggplot to plotly smooth \r\n  ggp <- plotly_build(p1a)\r\n  ggp$x$data[[1]]$text = paste(labTime, \": \", x_full, \"<br>\", labValue, \": \", round(y1,2) , sep =\"\" ) \r\n  ggp$x$data[[2]]$text = paste(labTime, \": \", f_full, \"<br>\", labValue, \": \", round(y2,2) , sep =\"\" ) \r\n  \r\n  if(length(ggp$x$data)>=3)\r\n  {\r\n    iii =  as.character(ggp$x$data[[3]]$x)\r\n    ggp$x$data[[3]]$text = paste(labTime, \": \", cf_full[iii], \"<br> lower: \", lower1[iii],\"<br> upper: \", upper1[iii], sep =\"\" ) \r\n  }\r\n  \r\n  if(length(ggp$x$data)>=4)\r\n  {\r\n    iii =  as.character(ggp$x$data[[4]]$x)\r\n    ggp$x$data[[4]]$text = paste(labTime, \": \", cf_full[iii], \"<br> lower: \", lower2[iii],\"<br> upper: \", upper2[iii], sep =\"\" ) \r\n  }\r\n  \r\n  \r\n  \r\n  ggp$x$layout$margin$l = ggp$x$layout$margin$l+10\r\n  #ggp$x$layout$margin$r = 0\r\n  if(ggp$x$layout$xaxis$tickangle < -40)\r\n    ggp$x$layout$margin$b = ggp$x$layout$margin$b+40\r\n  \r\n}\r\n\r\n############# Create and save widget ###############\r\n\r\np <- ggp\r\n\r\ndisabledButtonsList <- list('toImage', 'sendDataToCloud', 'zoom2d', 'pan', 'pan2d', 'select2d', 'lasso2d', 'hoverClosestCartesian', 'hoverCompareCartesian')\r\np$x$config$modeBarButtonsToRemove = disabledButtonsList\r\n\r\np <- config(p, staticPlot = FALSE, editable = FALSE, sendData = FALSE, showLink = FALSE,\r\n            displaylogo = FALSE,  collaborate = FALSE, cloud=FALSE)\r\n\r\ninternalSaveWidget(p, 'out.html')\r\n####################################################\r\n#display in R studio\r\nif(Sys.getenv(\"RSTUDIO\")!=\"\")\r\n  print(p)\r\n\r\n\r\n"}}}],"objects":{"rcv_script":{"properties":{"provider":{"type":{"text":true}},"source":{"type":{"scripting":{"source":true}}}}},"settings_forecastPlot_params":{"displayName":"Forecasting settings","description":"Forecasting settings","properties":{"forecastLength":{"displayName":"Forecast length","description":"Number of data points to predict","type":{"numeric":true}},"confInterval1":{"displayName":"Confidence level","description":"Select first confidence interval","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"0.2","value":"0.2"},{"displayName":"0.4","value":"0.4"},{"displayName":"0.5","value":"0.5"},{"displayName":"0.75","value":"0.75"},{"displayName":"0.8","value":"0.8"},{"displayName":"0.9","value":"0.9"},{"displayName":"0.95","value":"0.95"},{"displayName":"0.975","value":"0.975"},{"displayName":"0.98","value":"0.98"},{"displayName":"0.99","value":"0.99"},{"displayName":"0.995","value":"0.995"},{"displayName":"0.999","value":"0.999"}]}},"confInterval2":{"displayName":"Confidence level #2","description":"Select additional confidence interval","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"0.2","value":"0.2"},{"displayName":"0.4","value":"0.4"},{"displayName":"0.5","value":"0.5"},{"displayName":"0.75","value":"0.75"},{"displayName":"0.8","value":"0.8"},{"displayName":"0.9","value":"0.9"},{"displayName":"0.95","value":"0.95"},{"displayName":"0.975","value":"0.975"},{"displayName":"0.98","value":"0.98"},{"displayName":"0.99","value":"0.99"},{"displayName":"0.995","value":"0.995"},{"displayName":"0.999","value":"0.999"}]}}}},"settings_seasonality_params":{"displayName":"Seasonality","properties":{"show":{"type":{"bool":true}},"targetSeason":{"displayName":"Target seasonal factor","description":"Recommended seasonal factor. Incompatible inputs are ignored","type":{"enumeration":[{"displayName":"automatic","value":"automatic"},{"displayName":"manual","value":"manual"},{"displayName":"hour","value":"hour"},{"displayName":"day","value":"day"},{"displayName":"week","value":"week"},{"displayName":"month","value":"month"},{"displayName":"quater","value":"quater"},{"displayName":"year","value":"year"}]}},"knownFrequency":{"displayName":"Frequency","description":"Number of samples per season. Incompatible inputs are ignored.","type":{"numeric":true}}}},"settings_model_params":{"displayName":"Model Customization","properties":{"maxp":{"displayName":"Maximal p","description":"Maximal order of the autoregressive component","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"},{"displayName":"3","value":"3"}]}},"maxq":{"displayName":"Maximal q","description":"Maximal order of the moving average component","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"},{"displayName":"3","value":"3"}]}},"maxP":{"displayName":"Maximal P","description":"The maximal order of the seasonal autoregressive component","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"},{"displayName":"3","value":"3"}]}},"maxQ":{"displayName":"Maximal Q","description":"The maximal order of the seasonal moving average component","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"},{"displayName":"3","value":"3"}]}},"maxd":{"displayName":"Maximal d","description":"Maximal degree of differencing","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"}]}},"maxD":{"displayName":"Maximal D","description":"Maximal degree of seasonal differencing","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"}]}},"allowDrift":{"displayName":"Allow drift","description":"Allows the ARIMA model to include a linear drift term","type":{"bool":true}},"allowMean":{"displayName":"Allow mean","description":"Allows the ARIMA model include a mean term","type":{"bool":true}},"stepwiseSelection":{"displayName":"Stepwise selection","description":"TRUE performs a stepwise selection (faster), FALSE searches over all models (slow)","type":{"bool":true}},"boxCoxTransform":{"displayName":"Box-Cox transformation","description":"Family of transformations that includes logarithms and power transformations. The outcome depends on the `lambda` parameter. Recommended when the data show variation that increases or decreases with the level of the series","type":{"enumeration":[{"displayName":"off","value":"off"},{"displayName":"automatic","value":"automatic"},{"displayName":"manual","value":"manual"}]}},"lambda":{"displayName":"lambda","description":"Box-Cox transformation parameter","type":{"numeric":true}}}},"settings_userModel_params":{"displayName":"User defined model","properties":{"show":{"type":{"bool":true}},"p":{"displayName":"p","description":"Order of the autoregressive component","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"},{"displayName":"3","value":"3"}]}},"q":{"displayName":"q","description":"Order of the moving average component","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"},{"displayName":"3","value":"3"}]}},"P":{"displayName":"P","description":"Order of the seasonal autoregressive component","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"},{"displayName":"3","value":"3"}]}},"Q":{"displayName":"Q","description":"Order of the seasonal moving average component","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"},{"displayName":"3","value":"3"}]}},"d":{"displayName":"d","description":"Degree of differencing","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"}]}},"D":{"displayName":"D","description":"Degree of seasonal differencing","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"}]}}}},"settings_graph_params":{"displayName":"Graphical parameters","properties":{"dataCol":{"displayName":"History data color","type":{"fill":{"solid":{"color":true}}}},"forecastCol":{"displayName":"Forecast data color","type":{"fill":{"solid":{"color":true}}}},"percentile":{"displayName":"Opacity","type":{"numeric":true}},"weight":{"displayName":"Line width","type":{"numeric":true}}}},"settings_additional_params":{"displayName":"Info and warnings","properties":{"show":{"type":{"bool":true}},"textSize":{"displayName":"Font size","description":"Font size used to show information","type":{"numeric":true}},"textColor":{"displayName":"Text color","description":"Color used to show information","type":{"fill":{"solid":{"color":true}}}},"infoCriteria":{"displayName":"Output information criteria","description":"Used only for info, does not influence the results. Select one option: Akaike's Information Criterion (AIC), Corrected Akaike's Information Criterion (AICc), or Schwarz's Bayesian Information Criterion (BIC) ","type":{"enumeration":[{"displayName":"none","value":"none"},{"displayName":"AIC","value":"AIC"},{"displayName":"BIC","value":"BIC"},{"displayName":"AICc","value":"AICc"}]}}}}},"suppressDefaultTitle":true},"dependencies":{"cranPackages":[{"name":"zoo","displayName":"zoo: S3 Infrastructure for Regular and Irregular Time Series","url":"https://cran.r-project.org/web/packages/zoo/index.html"},{"name":"scales","displayName":"scales: Scale Functions for Visualization","url":"https://cran.r-project.org/web/packages/scales/index.html"},{"name":"reshape2","displayName":"reshape2: Flexibly Reshape Data: A Reboot of the Reshape Package","url":"https://cran.r-project.org/web/packages/reshape2/index.html"},{"name":"forecast","displayName":"forecast: Forecasting Functions for Time Series and Linear Models","url":"https://cran.r-project.org/web/packages/forecast/index.html"}]},"stringResources":{},"content":{"js":"var powerbi;!function(e){!function(e){!function(e){!function(e){function t(){r=0}function s(){return 0===r}function a(e,t){var s=[];if(e&&e.hasChildNodes()){for(var a=e.children,n=0;n<a.length;n++){var r=void 0;r=\"script\"===a.item(n).nodeName.toLowerCase()?i(a.item(n)):a.item(n).cloneNode(!0),t.appendChild(r),s.push(r)}return s}}function i(e){for(var t=document.createElement(\"script\"),s=e.attributes,a=0;a<s.length;a++)t.setAttribute(s[a].name,s[a].textContent),\"src\"===s[a].name.toLowerCase()&&(r++,t.onload=function(){r--});return t.innerHTML=e.innerHTML,t}function n(){var e=window.setInterval(function(){s()&&(window.clearInterval(e),window.hasOwnProperty(\"HTMLWidgets\")&&window.HTMLWidgets.staticRender&&window.HTMLWidgets.staticRender())},100)}var r=0;e.ResetInjector=t,e.injectorReady=s,e.ParseElement=a,e.RunHTMLWidgetRenderer=n}(e.PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML||(e.PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML={}))}(e.visual||(e.visual={}))}(e.extensibility||(e.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(e){!function(e){!function(e){!function(e){function t(e,t,s,a){if(e){var i=e[t];if(i){var n=i[s];if(void 0!==n)return n}}return a}function s(e,t,s,a,i,n){if(e){var r=e[t];if(r){var o=r[s];if(o<i)return i;if(o>n)return n;if(void 0!==o)return o}}return a}function a(e,t,s,a,i,n){if(e){var r=e[t];if(r){var o=r[s];if(void 0!==o)return o>n?n:o<i?i:o}}return a}function i(e,t,s,a,i,n){return n&&t==s&&1==i?a:n&&t!=s&&0==i?a:e}function n(e,t){return\"auto\"!=t?\"None\":\"auto\"==t&&\"None\"==e?\"fast\":e}function r(e,t,s){return e<t?t:e>s?s:e}function o(e,t,s,a,i){var n=e.objects;if(n){var r=n[t];if(r){var o=r[s];if(o){var l=o[a];if(void 0!==l)return l}}}return i}e.getValue=t,e.getValueMinMax=s,e.getValueNumberMinMax=a,e.ifStringReturnString=i,e.ifStringReturnStringClustersMethod=n,e.inMinMax=r,e.getCategoricalObjectValue=o}(e.PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML||(e.PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML={}))}(e.visual||(e.visual={}))}(e.extensibility||(e.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(e){!function(t){!function(t){!function(t){var s=[e.VisualUpdateType.Resize,e.VisualUpdateType.ResizeEnd,e.VisualUpdateType.Resize+e.VisualUpdateType.ResizeEnd],a=function(){function e(e){e&&e.element&&(this.rootElement=e.element),this.headNodes=[],this.bodyNodes=[],this.settings_forecastPlot_params={forecastLength:10,confInterval1:\"0.85\",confInterval2:\"0.95\"},this.settings_seasonality_params={show:!0,targetSeason:\"automatic\",knownFrequency:12},this.settings_model_params={maxp:\"3\",maxq:\"3\",maxP:\"2\",maxQ:\"2\",maxd:\"2\",maxD:\"1\",allowDrift:!0,allowMean:!0,stepwiseSelection:!0,boxCoxTransform:\"off\",lambda:.1},this.settings_userModel_params={show:!1,p:\"1\",q:\"1\",P:\"1\",Q:\"1\",d:\"1\",D:\"0\"},this.settings_graph_params={dataCol:\"blue\",forecastCol:\"orange\",percentile:40,weight:10},this.settings_additional_params={show:!0,textSize:12,textColor:\"brown\",infoCriteria:\"none\"}}return e.prototype.update=function(e){if(e&&e.type&&e.viewport){var t=e.dataViews;if(t&&0!==t.length){var a=t[0];if(a&&a.metadata){this.updateObjects(a.metadata.objects);var i=null;a.scriptResult&&a.scriptResult.payloadBase64&&(i=a.scriptResult.payloadBase64),s.indexOf(e.type)===-1&&i&&this.injectCodeFromPayload(i),this.onResizing(e.viewport)}}}},e.prototype.onResizing=function(e){},e.prototype.injectCodeFromPayload=function(e){if(t.ResetInjector(),e){var s=document.createElement(\"html\");try{s.innerHTML=window.atob(e)}catch(e){return}if(0===this.headNodes.length){for(;this.headNodes.length>0;){var a=this.headNodes.pop();document.head.removeChild(a)}var i=s.getElementsByTagName(\"head\");if(i&&i.length>0){var n=i[0];this.headNodes=t.ParseElement(n,document.head)}}for(;this.bodyNodes.length>0;){var a=this.bodyNodes.pop();this.rootElement.removeChild(a)}var r=s.getElementsByTagName(\"body\");if(r&&r.length>0){var o=r[0];this.bodyNodes=t.ParseElement(o,this.rootElement)}t.RunHTMLWidgetRenderer()}},e.prototype.updateObjects=function(e){this.settings_forecastPlot_params={forecastLength:t.getValue(e,\"settings_forecastPlot_params\",\"forecastLength\",10),confInterval1:t.getValue(e,\"settings_forecastPlot_params\",\"confInterval1\",\"0.85\"),confInterval2:t.getValue(e,\"settings_forecastPlot_params\",\"confInterval2\",\"0.95\")},this.settings_seasonality_params={show:t.getValue(e,\"settings_seasonality_params\",\"show\",!0),targetSeason:t.getValue(e,\"settings_seasonality_params\",\"targetSeason\",\"year\"),knownFrequency:t.getValue(e,\"settings_seasonality_params\",\"knownFrequency\",12)},this.settings_model_params={maxp:t.getValue(e,\"settings_model_params\",\"maxp\",\"3\"),maxq:t.getValue(e,\"settings_model_params\",\"maxq\",\"3\"),maxP:t.getValue(e,\"settings_model_params\",\"maxP\",\"2\"),maxQ:t.getValue(e,\"settings_model_params\",\"maxQ\",\"2\"),maxd:t.getValue(e,\"settings_model_params\",\"maxd\",\"2\"),maxD:t.getValue(e,\"settings_model_params\",\"maxD\",\"1\"),allowDrift:t.getValue(e,\"settings_model_params\",\"allowDrift\",!0),allowMean:t.getValue(e,\"settings_model_params\",\"allowMean\",!0),stepwiseSelection:t.getValue(e,\"settings_model_params\",\"stepwiseSelection\",!0),boxCoxTransform:t.getValue(e,\"settings_model_params\",\"boxCoxTransform\",\"off\"),lambda:t.getValue(e,\"settings_model_params\",\"lambda\",.1)},this.settings_userModel_params={show:t.getValue(e,\"settings_userModel_params\",\"show\",!1),p:t.getValue(e,\"settings_userModel_params\",\"p\",\"1\"),q:t.getValue(e,\"settings_userModel_params\",\"q\",\"1\"),P:t.getValue(e,\"settings_userModel_params\",\"P\",\"1\"),Q:t.getValue(e,\"settings_userModel_params\",\"Q\",\"1\"),d:t.getValue(e,\"settings_userModel_params\",\"d\",\"1\"),D:t.getValue(e,\"settings_userModel_params\",\"D\",\"0\")},this.settings_graph_params={dataCol:t.getValue(e,\"settings_graph_params\",\"dataCol\",\"blue\"),forecastCol:t.getValue(e,\"settings_graph_params\",\"forecastCol\",\"orange\"),percentile:t.getValue(e,\"settings_graph_params\",\"percentile\",40),weight:t.getValue(e,\"settings_graph_params\",\"weight\",10)},this.settings_additional_params={show:t.getValue(e,\"settings_additional_params\",\"show\",!0),textSize:t.getValue(e,\"settings_additional_params\",\"textSize\",12),textColor:t.getValue(e,\"settings_additional_params\",\"textColor\",\"brown\"),infoCriteria:t.getValue(e,\"settings_additional_params\",\"infoCriteria\",\"none\")}},e.prototype.enumerateObjectInstances=function(e){var s=e.objectName,a=[];switch(s){case\"settings_forecastPlot_params\":a.push({objectName:s,properties:{forecastLength:Math.round(t.inMinMax(this.settings_forecastPlot_params.forecastLength,1,1e6)),confInterval1:this.settings_forecastPlot_params.confInterval1,confInterval2:this.settings_forecastPlot_params.confInterval2},selector:null});break;case\"settings_seasonality_params\":a.push({objectName:s,properties:{show:this.settings_seasonality_params.show,targetSeason:this.settings_seasonality_params.targetSeason},selector:null}),\"manual\"==this.settings_seasonality_params.targetSeason&&a.push({objectName:s,properties:{knownFrequency:t.inMinMax(this.settings_seasonality_params.knownFrequency,2,1e6)},selector:null});break;case\"settings_model_params\":a.push({objectName:s,properties:{maxp:this.settings_model_params.maxp,maxd:this.settings_model_params.maxd,maxq:this.settings_model_params.maxq}}),this.settings_seasonality_params.show&&a.push({objectName:s,properties:{maxP:this.settings_model_params.maxP,maxD:this.settings_model_params.maxD,maxQ:this.settings_model_params.maxQ}}),a.push({objectName:s,properties:{allowDrift:this.settings_model_params.allowDrift,allowMean:this.settings_model_params.allowMean,boxCoxTransform:this.settings_model_params.boxCoxTransform}}),\"manual\"==this.settings_model_params.boxCoxTransform&&a.push({objectName:s,properties:{lambda:t.inMinMax(this.settings_model_params.lambda,-.5,1.5)}}),a.push({objectName:s,properties:{stepwiseSelection:this.settings_model_params.stepwiseSelection},selector:null});break;case\"settings_userModel_params\":a.push({objectName:s,properties:{show:this.settings_userModel_params.show,p:this.settings_userModel_params.p,d:this.settings_userModel_params.d,q:this.settings_userModel_params.q},selector:null}),this.settings_seasonality_params.show&&a.push({objectName:s,properties:{P:this.settings_userModel_params.P,D:this.settings_userModel_params.D,Q:this.settings_userModel_params.Q},selector:null});break;case\"settings_graph_params\":a.push({objectName:s,properties:{dataCol:this.settings_graph_params.dataCol,forecastCol:this.settings_graph_params.forecastCol,percentile:this.settings_graph_params.percentile,weight:this.settings_graph_params.weight},selector:null});break;case\"settings_additional_params\":a.push({objectName:s,properties:{show:this.settings_additional_params.show,textSize:this.settings_additional_params.textSize,textColor:this.settings_additional_params.textColor,infoCriteria:this.settings_additional_params.infoCriteria},selector:null})}return a},e}();t.Visual=a}(t.PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML||(t.PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML={}))}(t.visual||(t.visual={}))}(e.extensibility||(e.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(e){!function(t){!function(t){t.PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML={name:\"PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML\",displayName:\"Forecasting with ARIMA\",class:\"Visual\",version:\"1.0.1\",apiVersion:\"1.4.0\",create:function(t){return new e.extensibility.visual.PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML.Visual(t)},custom:!0}}(t.plugins||(t.plugins={}))}(e.visuals||(e.visuals={}))}(powerbi||(powerbi={}));","css":".visual-PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML .rcv_autoScaleImageContainer{position:relative}.visual-PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML .rcv_autoScaleImageContainer .rcv_autoScaleImage{max-width:100%;max-height:100%;position:absolute;top:50%;left:50%;transform:translateY(-50%) translateX(-50%);-webkit-transform:translateY(-50%) translateX(-50%)}","iconBase64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAScwAAEnMBjCK5BwAAABl0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC4xMzQDW3oAAAJHSURBVDhPrZFdSJNRHMaPFkRoscCLiO6ELrrIWdkmLRtkEAjdSHjrRRAIRfQhCIFSSoXp6+xdUBAJpi1lH8QuNIIupA8JMsdM+4DoJhzIQsyWtb1Pzzmdzea0lvaDh53zf8//dz4mJB0e087Y1IRgUpzDlKjT03+HsseMW44xIcopA6Xj6uNqyBJOiTZmSElfC6dakAftoUi9HuYI3zIuZpSnNNSCv0CZm4GeLgrxRlTJk8kaZbUcf1IL/gBFdubz8sJJcZ0JICp2qvx6y6N6WQ6U2JgPUraScJqSiSXp08tyoGQsLev0v8gWRh85mtj8TpcU8k/hJknERLEuZaDkjhSd7RlF5PYxLPSXAqcKt6iPUshGi4JmVdDUtD4sYD3K+nFdUlDUctk/jkZjADO3nEjc2wNv7/3sE3q9V6v1NAMAEX9iK+JPgS5JWf2lwTHMhaqRGtiL52YDjPCr5d9QTzNIIU+5jlFXZpP9ys3g7Fy/E6mhSvT4/EqUjmqSLBXKq+phWriBDRvPm+HZZGgfEg8O4VrgZZZsRSEaxHpV/A25QeRMWXcqUAmjNzzD5hiTYOJMkGlhFm+YFqKpqMTy7bbQVxbD3V3PcLGkhhuUIuCYt8L7k++bXYfZuIPZxmzS7bloocsKH4hbw+4ELmyuw8iRBfgd8wg5geGDX+TJ5ZvmhRQG205UWL7y74nTxdt1WYGThVv1MH88N8yRb8Gqrz8GnR91aW0YXV1PrYAD/sbaCl1aG/LKns52dHi6GXPV0br/iRA/AZqz0QSBTrQ6AAAAAElFTkSuQmCC"}}